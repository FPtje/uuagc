imports
{
import Debug.Trace -- DEBUG
import Data.List(sortBy) --DEBUG
import Data.List(elemIndex)
import Control.Monad(liftM)
import qualified Data.Array as Array
import Data.Array({-DEBUG(!)-},bounds,inRange)
import Data.List(sort,mapAccumL,find)
import qualified Data.Graph as Graph
import qualified Data.Tree  as Tree
import SequentialComputation
import SequentialTypes
import CodeSyntax
import GenerateSeqCode
import GrammarInfo
}

{ {-DEBUG-}
(!) :: Show a => Array.Array Graph.Vertex a -> Graph.Vertex -> a
arr ! e | Array.inRange (bounds arr) e = arr Array.! e
        | otherwise = error ("(!) error " ++ show e ++ " in " ++ show arr)

sort' = sortBy (\(a,_) (b,_) -> a `compare` b)
showlist xs = "[\n" ++ showlist' xs ++ "]\n"
showlist' [] = ""
showlist' [x] = show x
showlist' (x:xs) = show x ++ "\n" ++ showlist' xs
}


------------------------------------------------------------------
-- Building a mapping from Vertices to Ints
------------------------------------------------------------------
ATTR Productions Production Alternatives Alternative Rules Rule 
   [ allvertices'  : {[(Graph.Vertex,AttrOcc)] } | | ]

ATTR Production  Alternative  Child    Rule
     Productions Alternatives Children Rules 
     [ | vcount : Int | vertices' USE {++} {[]} : {[(Graph.Vertex,AttrOcc)]} ]
ATTR Pattern Patterns
     [ | | vertices' USE {++} {[]} : {[AttrOcc]} ]

SEM Alternative
  | Alternative loc.vertices' = zip [@lhs.vcount..] ([ AOLHSInh @lhs.nt @con inh | inh <- @inhnames ])
                lhs.vertices' = @vertices' ++ @children.vertices' ++ @rules.vertices'
                children.vcount = @lhs.vcount + length @inhnames

SEM Child
  | Child loc.maptolocal = Map.isEmpty @syn && Map.isEmpty @inh
          loc.vertices' = if  @maptolocal
                              then [(@lhs.vcount, AOLocal @lhs.nt @lhs.con @name)]
                              else zip [@lhs.vcount..] ([AORHSSyn (getNonterminalName @tp) @lhs.nt @lhs.con @name syn | syn <- (Map.keys @syn)])
          lhs.vcount    = @lhs.vcount + (if @maptolocal then 1 else Map.size @syn)

SEM Rule
  | Rule lhs.vcount = @lhs.vcount + length @pattern.vertices'
         loc.vertices' = zip [@lhs.vcount ..] @pattern.vertices'

SEM Pattern 
  | Alias  lhs.vertices' = let vertex | @field==_LHS = AOLHSSyn @lhs.nt @lhs.con @attr
                                      | @field==_LOC || @field == nullIdent = AOLocal @lhs.nt  @lhs.con @attr
                                      | otherwise    = AORHSInh fieldType @lhs.nt @lhs.con @field @attr
                               fieldType = maybe nullIdent getNonterminalName (lookup @field @lhs.fields)       
                           in vertex : @pat.vertices'

ATTR Children Child  [ | | terminals USE {++} {[]} : {[Name]} ]
SEM Child
  | Child lhs.terminals = if null ((Map.keys @syn) ++ (Map.keys @inh))
                            then [@name]
                            else []

-------------------------------------------------------------------------------
-- Needed from DEP.AG
-------------------------------------------------------------------------------

ATTR Pattern Patterns [ nt:{Identifier} | | ]
ATTR Pattern Patterns [ con:{Identifier} | | ]
ATTR Rules Rule Pattern Patterns [ fields:{[(Name,Type)]} | | ]
SEM Rule
  | Rule loc.(locAttrs, (inAttrs,outAttrs)) = let (locs,rest) = partition (\(fld,attr) -> fld==_LOC) @rhs.usedAttrs
                                              in (map snd locs, partition (\(fld,attr) -> fld==_LHS) rest)
{
getNonterminalName (NT nt) = nt
getNonterminalName _       = nullIdent
}

imports
{
import List(partition)
}

-------------------------------------
-- NT-Attributes
-------------------------------------
ATTR Productions Production [ | acount : Int | tdsToTdp USE {++} {[]} : {[(Graph.Vertex,[Graph.Vertex])]}
                                               ntattrs  USE {++} {[]} : {[(Graph.Vertex,NTAttr)]} 
                                               aranges  USE {++} {[]} : {[(Int,Int,Int)]}]

SEM Grammar
  | Grammar prods.acount = 0

SEM Production
  | Production lhs.tdsToTdp = zip [@lhs.acount ..]    ((map (\a -> lookupAttrOccWith (lookInh a) @lhs.allvertices') (Map.keys @inh))
                                                    ++ (map (\a -> lookupAttrOccWith (lookSyn a) @lhs.allvertices') (Map.keys @syn)))
                               where lookSyn a (AOLHSSyn nt _ a')     = nt == @nt && a == a'
                                     lookSyn a (AORHSSyn nt _ _ _ a') = nt == @nt && a == a'
                                     lookSyn _ _ = False
                                     lookInh a (AOLHSInh nt _ a')     = nt == @nt && a == a'
                                     lookInh a (AORHSInh nt _ _ _ a') = nt == @nt && a == a'
                                     lookInh _ _ = False
               lhs.ntattrs  = zip [@lhs.acount ..] ((map (NTAInh @nt) (Map.keys @inh)) ++ (map (NTASyn @nt) (Map.keys @syn)))
               lhs.acount = @lhs.acount + Map.size @inh + Map.size @syn
               lhs.aranges = [(@lhs.acount
                              ,@lhs.acount + Map.size @inh
                              ,@lhs.acount + Map.size @syn + Map.size @inh - 1)]

-----------------------------------------
-- Direct dependencies
-----------------------------------------
ATTR Productions Production 
     Alternatives Alternative 
     Rules Rule [ | | directDep USE {++} {[]} : {[Graph.Edge]} ]

SEM Rule
  | Rule lhs.directDep
             = let rhsSyn t (AORHSSyn _ nt' con' fld' attr') = (nt',con',fld',attr') == t
                   rhsSyn _ _ = False
                   translateOut (fld,attr) = lookupAttrOccWith (rhsSyn (@lhs.nt,@lhs.con,fld,attr)) @lhs.allvertices'
                   translateLoc attr       = lookupAttrOcc (AOLocal @lhs.nt @lhs.con attr) @lhs.allvertices'
                   translateIn  (fld,attr) = lookupAttrOcc (AOLHSInh @lhs.nt @lhs.con attr) @lhs.allvertices'
                   myUsedOut fld  = (\(x,y) -> (concatMap translateOut x,concatMap translateOut y)) $ partition (\(fld',_) -> fld' == fld) @outAttrs
                   usedOut  = concatMap translateOut @outAttrs
                   usedLoc  = concatMap translateLoc (@locAttrs ++ @rhs.usedLocals ++ @rhs.usedFields)
                   usedRest = concatMap translateIn @inAttrs
               in [ (x,y) | x <- usedOut ++ usedLoc ++ usedRest, (y,_) <- @vertices' ]

------------------------------------------------------------------
-- aTable for names and types of NTAttrs
------------------------------------------------------------------
ATTR  Productions Production 
      [ | | aTable USE {++} {[]} : {[(Graph.Vertex,(Name,Type))]} ]
SEM  Production
  |  Production  lhs.aTable = zip [@lhs.acount ..] (Map.toList @inh ++ Map.toList @syn)

------------------------------------------------------------------
-- ruleTable for CRules of attributes
------------------------------------------------------------------
ATTR Rules Rule [ childrenAttributes : {[(Name,Attributes,Attributes)]} inh,syn : Attributes | | ]
SEM  Alternative
  |  Alternative rules.childrenAttributes = @children.attributes

ATTR Productions Production 
     Alternatives Alternative 
     Rules Rule 
     Children Child [ | | ruleTable USE {++} {[]} : {[(Graph.Vertex,CRule)]} ]

SEM  Alternative
  |  Alternative lhs.ruleTable =  mapSnd (\ao -> CRule ao (Map.lookup (getAttr ao) @lhs.inh) False empty empty Map.empty False "") @vertices'
                                  ++ @children.ruleTable
                                  ++ @rules.ruleTable

SEM  Child
  |  Child  loc.ruleTable = if  @maptolocal
                                then [(@lhs.vcount, CRule (AOLocal @lhs.nt @lhs.con @name) (Just @tp) False empty empty Map.empty False "")]
                                else zip [@lhs.vcount..] [ (CRule (AORHSSyn (getNonterminalName @tp) @lhs.nt @lhs.con @name syn) (Just tp) False empty empty Map.empty False "")  | (syn,tp) <- Map.assocs @syn]

SEM  Rule 
  |  Rule  lhs.ruleTable = let  cr ao = CRule ao (getType ao) True @pattern.pp @rhs.pp defines @owrt @origin
                                defines = Map.fromList (map (\(v,ao) -> (v,(ao,getType ao))) @vertices')
                                findChildAttrs fld = find (\(f,_,_) -> f == fld) @lhs.childrenAttributes
                                getType (AOLocal _ _ a) = Map.lookup a @lhs.allTypeSigs
                                getType (AOLHSInh nt _ a) = Map.lookup a @lhs.inh
                                getType (AOLHSSyn nt _ a) = Map.lookup a @lhs.syn
                                getType (AORHSInh _ _ _ fld a) = let Just (_,inh,_) = findChildAttrs fld
                                                                 in Map.lookup a inh
                                getType (AORHSSyn _ _ _ fld a) = let Just (_,_,syn) = findChildAttrs fld
                                                                 in Map.lookup a syn
                                mkTp nt a = Just (SimpleType (typeToString nt a))
                           in mapSnd cr @vertices'
------------------------------------------------------------------
-- Pass structure up
------------------------------------------------------------------
ATTR Productions Production [ | | prods USE {++} {[]} : {[(Nonterminal,[Constructor])]} ]
SEM  Production
  |  Production  lhs.prods = [(@nt,@alts.cons)]
ATTR Alternatives Alternative [ | | cons USE {++} {[]} : {[Constructor]} ]
SEM  Alternative
  |  Alternative  lhs.cons = [@con]

------------------------------------------------------------------
-- Collect type signatures
------------------------------------------------------------------
ATTR TypeSigs TypeSig [ | typeSigs : {Map Name Type} | ]
SEM Alternative
  | Alternative typeSigs.typeSigs = Map.empty
SEM TypeSig
  | TypeSig lhs.typeSigs = Map.insert @name @tp @lhs.typeSigs

ATTR Rules Rule [ allTypeSigs : {Map Name Type} | | ]
SEM  Alternative
  |  Alternative rules.allTypeSigs = @typeSigs.typeSigs
------------------------------------------------------------------
-- Invoking sequential computation
------------------------------------------------------------------
SEM Grammar
  | Grammar loc.attrTable = Array.array (0,@prods.acount-1) @prods.ntattrs
            loc.aoTable = Array.array (0,@prods.vcount-1) @prods.vertices'
            loc.aTable = Array.array (0,@prods.acount-1) @prods.aTable
            loc.ruleTable = Array.array (0,@prods.vcount-1) @prods.ruleTable
            prods.allvertices' = @prods.vertices'
            prods.vcount  = 0
            loc.info      = Info { tdsToTdp   = Array.array (0,@prods.acount-1) @prods.tdsToTdp
                                 , tdpToTds   = Array.array (0,@prods.vcount-1) [ (ix, def (lookupWith' (ix `elem`) @prods.tdsToTdp)) | ix <- [0 .. @prods.vcount-1] ]
                                 , aoTable    = @aoTable
                                 , attrTable  = @attrTable
                                 , aTable     = @aTable
                                 , ruleTable  = @ruleTable
                                 , lmh        = @prods.aranges
                                 , prods      = @prods.prods
                                 , cyclesOnly = not (visit @lhs.options)
                                 }
                             where def [] = -1
                                   def (v:vs) = v
            loc.(cInterfaceMap,cVisitsMap,cyclesErrors) =
                              trace ("=== Numbering attributes ==="  ++ showlist (Array.assocs @attrTable) ++ "\n\n== Numbering attribute occurrences  ==" ++ showlist (Array.assocs @aoTable) ++ "\n\naTable ==" ++ show ( sort' @prods.aTable) ++ "\n\nruleTable ==" ++ show (sort' @prods.ruleTable) ++ "\n\ndirectdeps==" ++ show @prods.directDep {-DEBUG-}) $
                                         case computeSequential @info @prods.directDep of
                                           SeqResult    cim cvm -> trace ("ResultingVisitmap == " ++ concatMap (\k -> show k ++ ":=" ++ show (Map.keys (cvm Map.! k)) ++ "\n") (Map.keys cvm)) (cim,cvm,[])
                                           DirectCycle  errs -> (error "No interfaces for cyclic AG",error "No visit sub-sequences for cyclic AG",map (directCycleErr @attrTable @ruleTable) errs)
                                           InducedCycle cim errs -> (cim,error "No visit sub-sequences",  map (inducedCycleErr @attrTable) errs)
            lhs.errors := (if withCycle @lhs.options then Seq.fromList @cyclesErrors else Seq.empty) 
                          Seq.<> (if visit @lhs.options && null @cyclesErrors then @missingTypeSigs else Seq.empty)
                          Seq.<> @prods.errors

------------------------------------------------------------------
-- Generate CGrammar
------------------------------------------------------------------
-- Pass InterfaceMap down and select the Interface in the Production
ATTR Productions Production [ cInterfaceMap : CInterfaceMap | | ]
SEM  Production
  |  Production  loc.cInters = sem_CInterface (find' @nt @lhs.cInterfaceMap)

{ {-DEBUG-}
find' a map = case Map.lookup a map of
                Nothing -> error ("Map.find failed to find " ++ show a ++ " in " ++ show (Map.keys map))
                Just b -> b
}

-- Pass VisitMap down and select the CVisits in the Alternative
ATTR Productions Production Alternatives Alternative [ cVisitsMap : CVisitsMap | | ]
SEM  Alternative
  |  Alternative loc.cVisits = sem_CVisits (find' @con (find' @lhs.nt @lhs.cVisitsMap))

-- Now just build the CGrammar
SEM  Grammar
  |  Grammar  loc.cGrammar = sem_CGrammar_CGrammar @prods.cProductions
SEM  Productions [ | | cProductions : T_CProductions ]
  |  Cons  lhs.cProductions = @hd.cProduction `sem_CProductions_Cons` @tl.cProductions
  |  Nil   lhs.cProductions = sem_CProductions_Nil
SEM  Production [ | | cProduction : T_CProduction ]
  |  Production  lhs.cProduction = sem_CProduction_CProduction @nt @inh @syn @alts.cAlternatives @cInters
SEM  Alternatives [ | | cAlternatives : T_CAlternatives ]
  |  Cons  lhs.cAlternatives = @hd.cAlternative `sem_CAlternatives_Cons` @tl.cAlternatives
  |  Nil   lhs.cAlternatives = sem_CAlternatives_Nil
SEM  Alternative [ | | cAlternative : T_CAlternative ]
  |  Alternative  lhs.cAlternative = sem_CAlternative_CAlternative @con @cVisits @children.fields @children.terminals

------------------------------------------------------------------
-- Call CGrammar
------------------------------------------------------------------
SEM  Grammar
  |  Grammar  (prods.seqDecls,loc.missingTypeSigs)
                             = let  inh = Inh_CGrammar  { options_Inh_CGrammar = @lhs.options
                                                        , wrappers_Inh_CGrammar = @wrappers}
                                    syn = wrap_CGrammar @cGrammar inh
                               in (decls_Syn_CGrammar syn, missingTypeSigs_Syn_CGrammar syn)

SEM  Productions [ seqDecls : {[Decls]} | | ]
  |  Cons  hd.seqDecls = head @lhs.seqDecls
           tl.seqDecls = tail @lhs.seqDecls
SEM  Production [ seqDecls : {Decls} | | ]
  |  Production  loc.seqDecls = @lhs.seqDecls

{
directCycleErr :: Graph.Table NTAttr -> Graph.Table CRule -> (Graph.Edge,[Graph.Vertex]) -> Error
directCycleErr attrTable ruleTable ((v1,v2), path)
  = let (NTASyn nt a1) = attrTable ! v1
        (NTAInh _  a2) = attrTable ! v2
        look a | inRange (bounds ruleTable) a = [ruleTable ! a]
               | otherwise = []
        showPath = map showOrigin (concatMap look path)
        showOrigin (CRule ao _ hasCode _ _ _ _ origin) | hasCode && getName (getAttr ao) /= "self" = prettyAO ao ++ " (" ++ show (getPos (getAttr ao)) ++ ")"
                                                       | otherwise = prettyAO ao
    in DirectCirc nt a2 a1 showPath

inducedCycleErr :: Graph.Table NTAttr -> Graph.Edge -> Error
inducedCycleErr attrTable (v1,v2)
  = let (NTASyn nt a1) = attrTable ! v1
        (NTAInh _  a2) = attrTable ! v2
    in trace ("Induced cycle between " ++ show v1 {- ++ "(" ++ show a1 -} ++ ") and " ++ show v2 {- ++ "(" ++ show a2 -} ++ ") of " ++ show nt) $ InducedCirc nt a2 a1 -- DEBUG

-------------------------------------------------------------------------------
-- Some useful functions
-------------------------------------------------------------------------------
lookupAttrOcc :: AttrOcc -> [(b,AttrOcc)] -> [b]
lookupAttrOcc a bas = lookupAttrOccWith (a==) bas

lookupAttrOccWith :: (AttrOcc -> Bool) -> [(b,AttrOcc)] -> [b]
lookupAttrOccWith f [] = []
lookupAttrOccWith f ((b,a):abs)
    | f a       = b:lookupAttrOccWith f abs
    | otherwise = lookupAttrOccWith f abs

lookupWith' :: (a -> Bool) -> [(b,a)] -> [b]
lookupWith' f []       = []
lookupWith' f ((b,a):abs) 
    | f a       = b:lookupWith' f abs
    | otherwise = lookupWith' f abs


mapSnd :: (a -> b) -> [(c, a)] -> [(c,b)]
mapSnd f [] = []
mapSnd f ((c,a):cas) = (c,f a):mapSnd f cas
}
